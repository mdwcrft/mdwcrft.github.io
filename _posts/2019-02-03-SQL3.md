---
title: "SQL #3: SELECT"
date: 2019-02-01
tags: []
excerpt: ":three:"
mathjax: true
---

This is the third in a series of SQL notes I made during the [Kubrick](https://kubrickgroup.com/) Data Engineering training course. The others are:  
[#1: Database Theory]({{ site.url }}{{ site.baseurl }}/SQL1)  
[#2: Basic SQL]({{ site.url }}{{ site.baseurl }}/SQL2)   
[#4: Sorting]({{ site.url }}{{ site.baseurl }}/SQL4)  
[#5: CTE's, Views & JOIN]({{ site.url }}{{ site.baseurl }}/SQL5)  [#6: INDEX]({{ site.url }}{{ site.baseurl }}/SQL6)  
[#7: Transactions]({{ site.url }}{{ site.baseurl }}/SQL7)  
[#8: Other Functions]({{ site.url }}{{ site.baseurl }}/SQL8)  

All the posts in this series are my personal note taking and may be updated as the course progresses.  

---
`SELECT` is the query feature of SQL. It is used to find and pull out data from a table. While `SELECT` is simple in itself, it can be combined with many other key words and functions to form very complex queries. (All of the examples here are using data from the [AdventureWorks](https://github.com/Microsoft/sql-server-samples/releases/tag/adventureworks) dataset.)  

---
# Single SELECT
`SELECT` is the core syntax of SQL queries, a `SELECT` statement in it's simplest form queries a table with no filters:  

```sql
SELECT *
FROM Production.Product
```
### WHERE
A more specific query would state the column names and use `WHERE` to apply a logical condition on a column using an *equality operator*.  The precursor to comments is `--` in SQL.  

```sql
--VERTICAL FILTER (Columns):
SELECT
     [Name]
    ,[Color]
    ,[Partno]
FROM Production.Product
--HORIZONTAL FILTER (Rows):
WHERE [Cost] <= 500
```

The ISO standard equality operators are **=,<,>,>=,<=,<>**, SQL also has `BETWEEN`, `LIKE`, `IN`, and `EXISTS`.
`BETWEEN` specifies an inclusive number range:
```sql
SELECT * FROM Production.Product
WHERE ListPrict BETWEEN 50 AND 100
```  

`LIKE` matches strings using REGEX (`_` is ANY single character, `%` is ANY number of ANY character):
```sql
SELECT * FROM Production.Product
WHERE NAME LIKE 'A%'
```  

`IN` match against a chosen set of options:
```sql
SELECT *
FROM Production.Product
WHERE colour IN (‘silver’,’blue’,’green’)
```  

`EXISTS` matches where some row of a subquery exists:
```sql
SELECT ListPrice
FROM Production.Product
WHERE EXISTS
(SELECT SalesID FROM Sales.Sales WHERE OrderQty > 50);
```  

This `EXISTS` example shows an important feature of `WHERE` and other filters; they can use a subquery as an arguement. 
 
### HAVING, WHERE, FROM
`WHERE`(select rows) is an applied filter that can be used with `SELECT`, as is `FROM`. There is also `GROUP` (group rows sharing a property) and `HAVING`(select from the groups). They are applied by SQL in a specific order:

`SELECT`
- `HAVING`
- `GROUP`
- `WHERE`
- `FROM`

So they must be written in the opposite order for SQL to read it properly. `AS` can optionally be used to set an alias for a column or table. The following query shows products grouped by color, then by size which have an individual cost of < 1000 and a grouped cost of < 1000. 

```sql
SELECT 
     color
    ,size
    ,sum(standardcost) AS sumcost
    ,avg(standardcost) AS avcost
FROM Production.Product
    WHERE standardcost < 1000
    GROUP BY color, size
    HAVING sum(standardcost) < 1000
```
The order of the columns to be selected is arbritary unless exporting to Python or R when a particular order may be preferred. The following order should be roughly followed:  
1. Key columns
2. Attributes 
3. Dates
4. Numeric values
5. Ratios  
While SQL server is case insensitive, other systems are not so it's also a good idea to have **consistent casing** (either upper or lower).  
The user can also specify `DISTINCT` to return only distinct values. `TOP n` is used to return the top n values or `TOP n PERCENT` to return a percentage from the top. If the query is ordered and two values are tied then `TOP 1 WITH TIES` will return all the first tied values for example. 
The `INTO` command (before `FROM`) is used to save the query into a new table. 


---
# Order of Operations
SQL queries have a defined **logical** *order of operations* which is the order in which filters and groupings are applied. It's important to understand this order as it affects every aspect of how a `SELECT` statement is written. Confusingly, the *lexical* (written) order is different to the logical order, which is also different to the *actual* order of operations (apparently).   

The logical order of operations is:  
1. `FROM`: Choose table
2. `WHERE`: Filter rows
3. `GROUP BY`: Group filtered rows
4. Aggregations: Summarize rows
5. `HAVING`: Filter groups
6. `OVER`(Window): Aggregate over groups
7. `SELECT`: Filter columns
8. `DISTINCT`: Remove duplicates
9. `UNION`, `INTERSECT`, `EXCEPT`: Combine `SELECT` statements
10. `ORDER BY`: Choose ordering
11. `LIMIT`, `FETCH`, `TOP`: Filter ordered rows  

Each statement can only use arguements that are defined before it in the list. This means that for example;  
- `WHERE` can **not** include aggregations but window functions (`OVER`) can.   
- `ORDER BY` is the only statement that can use aliases defined by `SELECT`  

There are a few ways to get around the limitations of the single `SELECT`. The simplest is a nested `SELECT`.  

---
# Nested SELECT
A nest `SELECT` is an (inefficient) method for circumventing the logical order of operations and form a more complex query.  

Any example would be, to find the discontinued products from `Production.Product` we would need to search `Sales.SalesOrderDetail` for the most recent order. If the last time the product was modified was in the same year then it's probably still stocked. An `EXCEPT` statement can be used to find the products which are *not* in this list.  

```sql
SELECT ProductID FROM Production.Product
	except
	SELECT ProductID FROM Production.Product
	WHERE ProductID IN(
		SELECT ProductID FROM sales.SalesOrderDetail
			WHERE year(ModifiedDate) IN(
				SELECT 
					 max(year(orderdate)) lastorder
				FROM sales.SalesOrderHeader ))
```  