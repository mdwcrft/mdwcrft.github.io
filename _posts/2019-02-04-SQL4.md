---
title: "SQL #4: Sorting"
date: 2019-02-01
tags: []
excerpt: ":four:"
mathjax: true
---

This is the fourth in a series of SQL notes I made during the [Kubrick](https://kubrickgroup.com/) Data Engineering training course. The others are:  
[#1: Database Theory]({{ site.url }}{{ site.baseurl }}/SQL1)  
[#2: Basic SQL]({{ site.url }}{{ site.baseurl }}/SQL2)  
[#3: SELECT]({{ site.url }}{{ site.baseurl }}/SQL3)  
[#5: CTE's, Views & JOIN]({{ site.url }}{{ site.baseurl }}/SQL5)   [#6: INDEX]({{ site.url }}{{ site.baseurl }}/SQL6)  
[#7: Transactions]({{ site.url }}{{ site.baseurl }}/SQL7)  
[#8: Other Functions]({{ site.url }}{{ site.baseurl }}/SQL8)  

All the posts in this series are my personal note taking and may be updated as the course progresses.  

---
# Aggregation
Aggregations summarize a set of multiple values into a single output. This can be done for all values mathematically. A user can also define windows across which the values are summarized using `GROUP BY` or `OVER`.

### Mathematical
Most of the mathematical aggregation functions are self-explanatory. They are `MAX()`, `MIN()`, `COUNT()`, `SUM()`, `AVG()`, `STDEV()`, and `VAR()`. These functions are often combined with other aggregation methods to draw insight. 

---
# GROUP BY
`GROUP BY` is used to aggregate values by some grouping. It is an example of a *window function*, `GROUP BY` defines a *new level of detail* for the query. This means it can only return columns which are either in the `GROUP BY` or in the aggregation. For example:

```sql
    SELECT 
         color
        ,sum(standardcost) AS sumcost
        ,count(*) AS cnt
    FROM Production.Product
    GROUP BY color
```
This query displays the total standard costs of the products in `Production.Product` by colour. `color` is in the `GROUP BY` and both `standardcost` and `*` are aggregated.  

---
# OVER
`OVER` determines the partitioning and ordering of a set of rows before a window function is applied. It keeps the same level of detail as the original table. This means a single query can return both detailed AND aggregate data.  

The various options for `OVER` are listed below. 
```sql
OVER (    
    PARTITION BY <clause> 
    ORDER BY <clause>   
    ROW or RANGE <clause>   
      )
```  
### PARTITION BY
`PARTITION BY` acts a bit like a `GROUP BY`, applying an aggregate to a group.  

```sql
SELECT
     OrderLineID
    ,StockItemID
    ,UnitPrice
    ,AVG(UnitPrice) OVER (PARTITION BY StockItemID) Avg_LinePrice
From Sales.Orderlines
```  
This query will return some details about each product and an aggregates average price for that StockItemID. This allows us to compare the price for that particular product to the average for the line.  

### ORDER BY
`ORDER BY` is the final part of a `SELECT` statement and defines how to order the results after all of the other functions and aggregations have been applied. `ORDER BY` is *very* expensive for the server so should be **avoided** if possible.  


### ROW or RANGE
Examples of window functions applied to `OVER` statements:  
`ROW_NUMER(<col1>) OVER (ORDER BY <col2>)` - Gives a row number if ordered by a condition
`RANK(<col1>) OVER (ORDER BY <col2>)` - Like `ROW_NUMBER` but 'tied' values are given tied position in rank
`DENSE_RANK(<col1>) OVER (ORDER BY <col2>)` - Like `RANK` but tied values only occupy one rank value  
`NTILE(n)` - Segments data into `n` evenly sized 'tiles'. 

---
# LAG, LEAD, FIRST_VALUE, LAST_VALUE
These are four common **Analytics functions** that can be used over a window. 

### FIRST/LAST_VALUE
The following query gives the `OrderID` for the first order by each customer.  

```sql
SELECT
     CustomerID
    ,OrderID
    ,FIRST_VALUE(OrderID) OVER (PARTITION BY OrderID ORDER BY OrderDate, CustomerID ROWS UNBOUNDED PRECEDING)
FROM Sales.Sales
```
The `ROWS UNBOUNDED PRECEDING` setting specifies how far into the past or future to search. The options are `UNBOUNDED` or `CURRENT` for distance and `PRECEDING` or `FOLLOWING` to choose past or future.
 
### LAG/LEAD
Similar to `FIRST_VALUE` and `LAST_VALUE`, `LAG` and `LEAD` allow us to effectively join the table to itself on the partition keys and reach into the joined set to retrieve the next value, or previous value. `LEAD` gives the first value and `LAG` the last.  

---
# CASE
`CASE` acts as an `IF` function in SQL, and can include an `ELSE`, for example:

```sql
SELECT ListPrice
	,CASE
		WHEN ListPrice >= 2000 THEN 'Expensive'
		WHEN ListPrice >= 500 THEN 'Moderate'
		WHEN ListPrice > 0 THEN 'Cheap'
		WHEN ListPrice <= 0 THEN 'Free'
		ELSE 'Unknown'
	END price_bin
FROM Production.Product
```
This query would bin products by price and create a new column `price_bin` to store the definitions.  

---
# LIKE


---
# Ordinal & Positional Sorting
### Ordinal
`ORDER BY` Specifies a sort depending on some column or condition. `DESC` or `ASC` can be added, the default is `ASC`


### Positional
`FIRST_VALUE()` Gives first value of a sorted set

---
# Pivot
Pivot is a way of re-organising and aggregating tables. A table can be ''pivotted' to list the total price of each ProductCode by color:  

```sql
SELECT *
FROM
(
SELECT 
	 left(productnumber, 2) AS ProductCode
	,isnull(color, 'NA') Color
	,ListPrice
FROM Production.Product
) R

PIVOT
(
sum(listprice) for color IN ([NA], [Black], [Blue], [Grey], [Multi], [Red], [Silver] ,[Silver/Black] ,[White] ,[Yellow])
)Piv
```  

The pivot command can be useful when there are multiple columns with the same details except for one, multiple email addresses for 1 person for example. A second column can be made and pivotted into to store 'email2'. In that example there's no real aggregation but an aggregation *must* be defined, so just use `MAX()` or something.  
More likely is the need to 'unpivot' a table to group some spread out data into buckets if it was set out column wise:  

```sql
SELECT *
FROM
(
SELECT 
	 left(productnumber, 2) AS ProductCode
	,isnull(color, 'NA') Color
	,ListPrice
FROM Production.Product
) R

UNPIVOT
(
sum(listprice) for color IN ([NA], [Black], [Blue], [Grey], [Multi], [Red], [Silver] ,[Silver/Black] ,[White] ,[Yellow])
)Unpiv
```

The unpivot command knows that the columns in the `SELECT` statement are the unique combination of values by which to aggregate. 

### Dynamic Pivot
Typing every column to pivot on is slow, it is possible to do a dynamic pivot by declaring a list of columns to pivot on.  

```sql
DECLARE @cols NVARCHAR(max)
DECLARE @query NVARCHAR(max)

SET @cols = stuff((SELECT DISTINCT ',' +
quotename(AgeBucket)
FROM training.populationByAge c
for XML PATH(''), TYPE
).VALUE('.', 'nvarchar(max)')
,1,1,'')

SELECT @cols
```  

`@cols` now stores a list of age buckets that could be used for a pivot. `NVARCHAR` must be used here becuase dynamic SQL commands require Unicode.

---
# Functions

### CAST
`CAST(<val> AS DATE)` - Treats the supplied value as some other format
`TRY_CAST(<val> AS DATE)` - Same as `CAST` but enters NULL if there's an error

### Missing Data
`ISNULL(<col>, <'N/A'>)` - Replaces `NULL` with value 'NA'.
`NULLIF(<col>)` - Replaces a value with `NULL`
`COALESCE()` - Gives first value from list that is `NOT NULL`

### Maths
`CEILING()` - Round up
`FLOOR()` - Round down
`ROUND(,D)` - Round to D decimal places
`DECIMAL(,P,S)` - Round to P total digits and S significant figures
`CHECKSUM()` - Computes a hash as a number
`NEWID()` - Computes a random ID string
`RAND()` - Random number betweeen 0-1