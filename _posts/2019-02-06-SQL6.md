---
title: "SQL #6: INDEX"
date: 2019-02-01
tags: []
excerpt: ":six:"
mathjax: true
---

This is the sixth in a series of SQL notes I made during the [Kubrick](https://kubrickgroup.com/) Data Engineering training course. The others are:  
[#1: Database Theory]({{ site.url }}{{ site.baseurl }}/SQL1)  
[#2: Basic SQL]({{ site.url }}{{ site.baseurl }}/SQL2)  
[#3: SELECT]({{ site.url }}{{ site.baseurl }}/SQL3)  
[#4: Sorting]({{ site.url }}{{ site.baseurl }}/SQL4)  
[#5: CTE's, Views & JOIN]({{ site.url }}{{ site.baseurl }}/SQL5)  
[#7: Transactions]({{ site.url }}{{ site.baseurl }}/SQL7)  
[#8: Other Functions]({{ site.url }}{{ site.baseurl }}/SQL8)  

All the posts in this series are my personal note taking and may be updated as the course progresses.  

---
# Indexes
Database access usually accounts for the biggest share of disk-IO in any system and frequently consumes more memory (cache) and processor cycles than other kinds of workload. In SQL server the smallest basic unit of storage is a **page** which is **8Kb** (8192 bytes).  

An index can be thought of in the same way as an index in a book.  The more 'selective' a dataset is, the more useful it is to have an index to prevent the server searching many unique values.  

The main index techniques you will come across in SQL Server are:  
- B+Tree index (clustered and non-clustered) **MAIN**  
- Column store  
- Spatial index  
- XML index  

Each of these index the data in different ways, **B-Tree** is the most common and has two index methods: **clustered** (all columns) and **non-clustered** (selected columns). A B-Tree is like a decision tree with an associated *depth* (number of levels), the lowest level of the tree is called the *leaf level*. A **B+Tree** structure makes range scan queries more efficient by putting every value into the leaf level of the tree and then chaining those leaves together with pointers. In a database index this is referred to as a **page chain** and it is *doubly-linked* so the chain can be traversed in both directions. Having an index means the server can **SEEK** by index instead of a **SCAN** of every row, and seeking is *much* more computationally efficient.   

---
# Non-Clustered Index
A non-clustered index is one where the leaf level of the index contains **rowIDs** pointing to rows of data. It acts like a look-up table for the server to use for finding a specific item quickly. There can be *many* clustered indexes for one table. Creating an index is like creating a table:  

```sql
CREATE INDEX [name] ON Customer([Name])
```  

Where `[Name]` is a highly unique column. Searching via the index is then achieved by a normal select:  
```sql
SELECT [name], [address], [city], [country]
FROM Customer
WHERE [name] = 'Jake'
```  

If you `INDEX` on a `VIEW` a 'materialised view' is created as the index creates a real object from the query that the view contained. 

---
# Clustered Index 
A clustered index is one where the leaf level of the index contains **rows of data**. There can only be *one* clustered index for a table (it is the table). The clustered index acts like a B+Tree until the leaf level, where all the actual data is contained, including fields which aren't part of the index key. The data is however **sorted** in index key order which is a big advantage for *range scans*.  

So the clustered index is essentially an ordered version of the table. It is usually good practice for every table to have a clustered index. A table without a clustered index is called a **heap** because the data rows are not logically ordered.

---
The following table lists the advantages and uses of different index schemes on tables. 

|Index Type|Attributes|
|---|---|
|Heap|Good for `INSERT`|
|Clustered Index|1 per table, leaf contains sorted data row, Does NOT allow `FILTER` or `INCLUDE`|
|Non-Clustered Index (On Heap)|999 per table(max), leaf contains RowIDs, `FILTER` and `INCLUDE` to select fields|
|Non-Clustered Index (On Clustered Index)|999 per table(max),leaf contains cluster key, `FILTER` and `INCLUDE` to select fields|