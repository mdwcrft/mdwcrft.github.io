---
title: "SQL #6: INDEX"
date: 2019-02-01
tags: []
excerpt: ":six:"
mathjax: true
---

This is the sixth in a series of SQL notes I made during the [Kubrick](https://kubrickgroup.com/) Data Engineering training course. The others are:  
[#1: Database Theory]({{ site.url }}{{ site.baseurl }}/SQL1)  
[#2: Basic SQL]({{ site.url }}{{ site.baseurl }}/SQL2)  
[#3: SELECT]({{ site.url }}{{ site.baseurl }}/SQL3)  
[#4: Sorting]({{ site.url }}{{ site.baseurl }}/SQL4)  
[#5: CTE's, Views & JOIN]({{ site.url }}{{ site.baseurl }}/SQL5)  
[#7: Transactions]({{ site.url }}{{ site.baseurl }}/SQL7)  
[#8: Other Functions]({{ site.url }}{{ site.baseurl }}/SQL8)  
All the posts in this series are my personal note taking and may be updated as the course progresses.  

# Indexes
Database access usually accounts for the biggest share of disk-IO in any system and frequently consumes more memory (cache) and processor cycles than other kinds of workload. In SQL server the smallest basic unit of storage is a **page** which is **8Kb** (8192 bytes).  

An index can be thought of in the same way as an index in a book.  The more 'selective' a dataset is, the more useful it is to have an index to prevent the server searching many unique values.  

The main index techniques you will come across in SQL Server are:  
- B+Tree index (clustered and non-clustered) **MAIN**  
- Column store  
- Spatial index  
- XML index  

Each of these index the data in different ways, B+Tree is the most common and has two index methods: **clustered** (all columns) and **non-clustered** (selected columns). A B-Tree is like a decision tree with an associated *depth* (number of levels), the lowest level of the tree is called the *leaf level*.

A clustered index actually contains all of the data so is essentially the original table. A non-clustered index however is a specific index table for a few chosen columns.  

A non-clustered index is like a look-up table for the server to use for finding a specific item quickly. This means the server can **SEEK** instead of **SCAN**, and seeking is *much* more computationally efficient.  

The syntax is
```sql
CREATE INDEX <index1> ON <table1>(<col1>,<col1>)
```  

Where `col1` is the most unique column.   


If you `INDEX` on a `VIEW` a 'materialised view' is created as the index creates a real object from the query that the view contained. 